<section class="ssr-csr-page container">
    <section class="intro">
        <h1>SSR &amp; CSR</h1>
            <p>
                In web development rendering is a process that turns website code into
                interactive pages users see when they visit a website.
                For us, that means the HTML, CSS and Javascript code.
            </p>
            <p>
                This is typically done by a rendering engine.
                Now, depending on where that rendering happens, we talk about 
                <strong>Server-Side Rendering (SSR)</strong> or <strong>Client-Side Rendering (CSR)</strong>
            </p>
            <p>
                Both achieve the same goal, but they do it in different ways.
            </p>
    </section>

    <section class="topic">
        <h2>Server-Side Rendering</h2>
            <p>
                As the name states, the <strong>server</strong> builds the HTML for each request,
                and sends the fully rendered page to the browser. This means the browser can show the content immediately.
            </p>
            <section class="code-group">
<pre><code>
// flow for SSR
Browser --> GET /friends --> server
server fetches data --> renders HTML etc. --> sends to browser
</code></pre>
            </section>
            <p>
                In Express, you can achieve SSR by assembling your page before you send it to the browser.
                First, you need to create a simple templating engine:
            </p>
            <section class="code-group">
<pre><code>
// templatingEngine.js
import fs from 'fs';

const header = readPage("./public/components/header/header.html");
const footer = readPage("./public/components/footer/footer.html");

export function constructPage(pageContent, options = {}) {
    return header
     .replace('$$TAB_TITLE$$', options.tabTitle || "Portfolio")
     .replace('$$CSS_LINKS$$', options.cssLinks || "")
      + pageContent
      + footer;
}

export function readPage(path) {
    return fs.readFileSync(path).toString();
}
</code></pre>
            </section>
            <p>
                This module reads the HTML file directly from disk using the <strong>fs</strong> module.
                The <strong>readPage()</strong> function loads a file, and converts it to a string.
                The <strong>constructPage()</strong> function combines the header, page content and footer into one HTML document.
            </p>
            <section class="code-group">
<pre><code>
// pagesUtil.js
import { readPage, constructPage } from './templatingEngine.js';

frontPage = readPage("./public/pages/index.html");

export const frontendPage = constructPage(frontPage, {
    tabTitle: "Frontpage | Welcome",
    cssLinks: `
        &ltlink rel="stylesheet" href="/assets/css/main.css"&gt;
    `
});
</code></pre>
            </section>
            <p>
                in pagesUtil.js we use the engine from before to build the <strong>frontendPage</strong>.
                We read the HTML for the front page, and wrap it with the shared header and footer.
                This will give us a fully rendered HTML page, that is ready to be sent to the client
            </p>
            <section class="code-group">
<pre><code>
// app.js
import { frontendPage } from './util/pagesUtil.js'

app.get("/", (req, res) => {
    res.send(frontendPage);
});
</code></pre>
            </section>
            <p>
                Finally, in app.js we simply respond to requests on <strong>"/"</strong> by sending the assembled HTML page.
            </p>
            <p>
                But wait! we're used to sending static files to the client via <code>res.sendFile()</code>,
                so why don't we use that? That's because <code>res.sendFile()</code> sends a static file from
                disk as it is. It doesn't allow for inserting dynamic data, change titles or combining components.
            </p>
            <p>
                So why would you use SSR you ask? You get faster initial load time, 
                since the user doesn't have to wait for Javascript to build the page. 
                It's also great for SEO (Search Engine Optimatization) since search engines
                can read the fully rendered HTML page.
            </p>
            <p>
                Now, there are downsides to this as with everything. One is higher server load,
                since the server has to must process and render each page request every time.
            </p>
    </section>

    <section class="topic">
        <h2>Client-Side Rendering</h2>
            <p>
                In <strong>Client-Side Rendering</strong> the browser first loads a minimal HTML file,
                and then builds and updates the page using Javascript.
                The rendering happens in the browser instead of on the server.
            </p>
            <section class="code-group">
<pre><code>
// flow for CSR
Browser --> GET /friends
Browser loads JS --> JS fetches data --> JS builds HTML in the browser
</code></pre>
            </section>
            <p>
                Unlike SSR, the browser recieves a mostly empty HTML file
                that Javascript fills dynamically.
            </p>
            <section class="code-group">
<pre><code>
// index.html
&ltbody&gt
    &ltul id="friends-list"&gt&lt/ul&gt
    &ltscript src="/assets/js/friends.js"&gt&lt/script&gt
&lt/body&gt
</code></pre>
            </section>
            <p>
                And in the javascript file <code>friends.js</code>:
            </p>
            <section class="code-group">
<pre><code>
fetch("/api/friends")
    .then(res =&gt res.json())
    .then(data =&gt {
        const list = document.getElementById("friends-list");
        data.forEach(friend =&gt {
            const li = document.createElement("li");
            li.textContent = friend.name;
            list.appendChild(li);
        });
    });
</code></pre>
            </section>
            <p>
                Here, the HTML file is loaded once, and the Javascript fetches
                the data from the server. The the DOM elements are created and data injected dynamically.
            </p>
            <p>
                So again, what is good about CSR? Well, the opposite of SSR - less server load.
                Also, the page can dynamically updated without the page reloading.
            </p>
            <p>
                On the contrary, CSR is slower on initial load since the user must wait for the Javascript
                to execute and fill the DOM. It is also not ideal for SEO since the search engines don't
                know the content of the page.
            </p>
    </section>

    <section class="topic">
        <h2>Conclusion</h2>
            <p>
                So, in conclusion: use SSR when SEO and fast first impressions matter.
                Use CSR when you are building dynamic web apps with heavy user interaction.
            </p>
    </section>
</section>