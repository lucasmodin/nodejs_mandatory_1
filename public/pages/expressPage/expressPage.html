<section class="express-page container">
    <section class="intro">
        <h1>Express</h1>
            <p>
                Express.js is a minimal and flexible web framework.
                It makes it easy to build web servers and REST APIs.
            </p>
            <p>
                You could think of it as this: Express is to Node what Spring Boot is to Java.
            </p>
    </section>

    <section class="topic">
        <h2>Setting up an Express project</h2>
            <p>
                To use Express, install the dependency with: <code>npm install express</code>.
            </p>
            <p>
                Then import and initialize it in your project:
            </p>
            <section class="code-group">
<pre><code>
// app.js
import express from 'express';

const app = express();
</code></pre>
            </section>
            <p>
                Now that Express is initialized, you need to configure the port it should listen on:
            </p>
            <section class="code-group">
<pre><code>
// app.js
app.listen(8080, () => {
    console.log("running on port 8080");
});
</code></pre>
            </section>
            <p>
                You're now up and running with your own web server in a few lines of code, easy peasy.
            </p>

    </section>

    <section class="topic">
        <h2>Routes</h2>
            <p>
                Routes defines how your app responds to different HTTP requests.
                The HTTP methods are as follows: GET, POST, PUT, PATCH and DELETE
            </p>
            <p>
                Im not gonna explain them in detail here (see REST page),
                but here are some examples on how to use them in your app:
            </p>
            <section class="code-group">
<pre><code>
// GET
app.get("/api/friends", (req, res) => {
    const friends = ["John", "Mark", "Oliver"];
    res.send({ data: friends });
});
</code></pre>
            </section>
            <p>
                This route handles a GET request to <code>/api/friends</code>.
                When the client calls this endpoint, the server will respond with a data object containing the list.
            </p>
            <p>
                Now, if the client wanted to add a new friend to the list,
                it would look something like this:
            </p>
            <section class="code-group">
<pre><code>
// POST
app.post("/api/friends", (req, res) => {
    const newFriend = req.body.name;
    friends.push(newFriend);
    res.status(201).send({ message: `${newFriend} added` })
})
</code></pre>
            </section>
            <p>
                We use <code>req</code> (request) to access data sent from the client.
                In this case <code>req.body.name</code> from the request body.
            </p>
            <p>
                The <code>res</code> (response) is the data we send back to the client.
                Here we use the status code 201 to indicate success and <code>send</code> to return a message.
            </p>
            <p>
                Now, for POST request, it is important to include:
            </p>
            <section class="code-group">
<pre><code>
app.use(express.json())
</code></pre>
            </section>
            <p>
                This allows Express to read JSON data from the request (body parsing).
            </p>

    </section>

    <section class="topic">
        <h2>Path Variables &amp; Query Parameters</h2>
            <p>
                If we wanted to, let's say, get a specific friend from the list,
                we could include their ID in the URL using a <strong>path variable</strong>.
            </p>
            <section class="code-group">
<pre><code>
// path variable example
app.get("/api/friends/:id", (req, res) => {
    const friendsId = Number(req.params.id);
    const foundFriend = friends.find(friend => friend.id === friendsId);
    res.send({ data: foundFriend });
})
</code></pre>
            </section>
            <p>
                The colon <code>:</code> marks <code>id</code> as a dynamic value.
            </p>
            <p>
                It's important to note, that the path variables are always strings.
                If your ID is a number, you need to parse it using <strong>Number()</strong>.
            </p>
            <p>
                On the other hand, we have <strong>query parameters</strong>.
                If we wanted to find our friend named John, we could do so by including 
                <code>Mark</code> in our URL:
            </p>
            <section class="code-group">
<pre><code>
// request: /api/friends/?name=mark
app.get("/api/friends", (req, res) => {
    const { name } = req.query;
    const foundFriend = friends.find(friend => {
        return friend.name === name;
    });
    res.send({ data: foundFriend });
});
</code></pre>
            </section>
            <p>
                The route will check the <code>name</code> query parameter in the URL,
                and search the friends list for a match and then return it to the client.
            </p>
            <p>
                Now, if our friends list didn't have Mark in it, we would be in a bit of a pickle.
                To handle this, we could add a simple check and return the HTTP status code: <strong>404 Not Found</strong>.
            </p>
            <section class="code-group">
<pre><code>
// request: /api/friends/?name=mark
app.get("/api/friends", (req, res) => {
    const { name } = req.query;
    const foundFriend = friends.find(friend => {
        return friend.name === name;
    });

    if(!foundFriend) {
        return res.status(404).send({ error: "friend not found"});
    }

    res.send({ data: foundFriend });
});
</code></pre>
            </section>
            <p>
                The <code>res.status</code> let's you send HTTP status codes with your response
            </p>
    </section>

    <section class="topic">
        <h2>Routers (more routes)</h2>
            <p>
                When your app grows, so will your routes. Instead of putting them all in one file,
                you can split them up usiong <strong>Express Routers</strong>.
                This will keep your code more organized and avoids long messy files.
            </p>
            <section class="code-group">
<pre><code>
// friendsRouter.js
import { Router } from "express";
const router = Router();

router.get("/", (req, res) => {
    res.send({ data: ["John", "Mark", "Oliver"] });
});

router.post("/", (req, res) => {
    res.send({ message: "friend added" });
});

export default router;
</code></pre>
            </section>
            <p>
                And in your app.js:
            </p>
            <section class="code-group">
<pre><code>
// app.js
import express from "express";
import friendsRouter from "./routes/friendsRouter.js";

const app = express();
app.use(express.json());

// mount the router
app.use("/api/friends", friendsRouter);

app.listen(8080, () => {
    console.log("Server running on port 8080");
});
</code></pre>
            </section>
            <p>
                Now, all the routes inside <strong>friendsRouter</strong>
                will automatically be prefixed with <strong>/api/friends</strong>
            </p>
            <p>
                This makes your code more modular and clean.
            </p> 
    </section>

    <section class="topic">
        <h2>Static Files</h2>
            <p>
                Static files are files that don't change when your app runs.
                This could be images, CSS, and client sided Javascript.
            </p>
            <p>
                You can serve these directly by using:
            </p>
            <section class="code-group">
<pre><code>
app.use(express.static("public"))
</code></pre>
            </section>
            <p>
                This tells Express to look for static assets inside your <code>public</code> folder.
            </p>
            <p>
                If you're using <strong>CommonJS</strong>, you can get the absolute path to your files
                by simply using <code>__dirname</code>. 
            </p>
            <p>
                It wil give you the absolute path to the folder where the current file is located.
                So when you expose an endpoint: 
            </p>
            <section class="code-group">
<pre><code>
// CommonJS
app.get("/", (req, res) => {
    res.sendFile(__dirname + "/public/index.html");
});
</code></pre>
            </section>
            <p>
                The server always knows where your files are located.
            </p>
    </section>
    <section class="topic">
        <h2>The public/ folder</h2>
            <p>
                When building a fullstack project (especially monolithic) it is easy to mix client and server files together.
                That's why we keep a clear seperate line between client and server files.
            </p>
            <p>
                The <strong>public/</strong> folder contains everything the client (browser) needs.
                Like HTML, CSS, Javascript and images.
            </p>
            <section class="code-group">
<pre><code>
public/
├─ assets/
|   ├─ css/
|   ├─
|   └─
|
|
|
└
</code></pre>

            </section>

    </section>
</section>