<section class="js-page container">
    <section class="intro stack">
        <h1>Javascript</h1>
            <p class="lead muted">
                Javascript is a fun programming language.
                It uses coerced data types and is dynamically typed.
                Meaning the interpreter determines and converts types automatically.
            </p>

            <p>
                If you're coming from a strictly typed language e.g. Java (like me),
                you're likely to be pretty confused.
                So lets go through it.
            </p>
    </section>

    <section class="topic">
        <h2>Data types</h2>
            <p>As stated before, data types are coerced and not strictly typed.</p>
            <p>It depends on the value stored in the variable. </p>
            <p>We categorize between two main categories of data types:</p>
                <ul>
                    <li><strong>Primitive types:</strong> string, number, boolean, undefined, null </li>
                    <li><strong>Reference types:</strong> object, array, function</li>
                </ul>
            <p>Example:</p>
            <section class="code-group">
<pre><code>
const age = 26; // primitive - type: number
const name = "Lucas"; // primitive - type: string
const isLearningJavascript = true; // primitive - type: boolean
const user = undefined; // primitive - type: undefined
const response = null; // primitive - type: null

const admin = { name: "Lucas" }; //reference - type: object
const subjects = ["node.js", "low level C", "IT-security"]; //reference - type: array
const doSomething = () => ({}); // reference - type: function
</code></pre>
            </section>
            <p>You can get the data type of any variable by using the <strong>typeof</strong> operator</p>
            <section class="code-group">
                <pre><code>
console.log(typeof age); // expected output: "number"
                </code></pre>
            </section>
    </section>

    <section class="topic">
        <h2>Scope and variables</h2>
            <p>In Javascript there are three ways to declare a variable:</p>
                <section class="code-group">
<pre><code>
var age = 26; 
let job = "developer";
const name = "Lucas";
</code></pre>
                </section>
            <p>
                Now, a fun fact is that <strong>const</strong> and <strong>let</strong> didn't exist before 
                2015. They were introduced with ES6 (ECMAScript 2015) mainly due to Javascript not having 
                block scoped variables before that. 
            </p>
            <p>
                This is quite unusual if, again, you come from Java
                which only has block scope variables.
            </p>
            <p>
                <strong>var</strong> has what we call <strong>function scope.</strong>
                Meaning the variable can be accessed anywhere within a function:
            </p>
                <section class="code-group">
<pre><code>
function lovesJavascript() {
if (true) {
    var message: "You're like me!";
}
console.log(message) // output: "You're like me!";
}

console.log(message) // it will throw a reference error! 
</code></pre>
                </section>
            <p>
                It is pretty easy to see, that this is not optimal.
                By having access to variables outside of their intended block,
                you're prone to introducing bugs and unexpected behaviour.
            </p>
            <p>
                The solution: <strong>let</strong> and <strong>const</strong>.
                Both are block scoped, but there are key differences.
                <strong>let</strong> can be updated, <strong>const</strong> can not
            </p>
                <section class="code-group">
<pre><code>
let age = 26;
age = 27; //will work

const willDie = true;
willDie = false; // will throw a type error
</code></pre>
                </section>
            <p>
                We prefer to use <strong>const</strong> wherever we can due to the immutability,
                use <strong>let</strong> where we can't use const (due to reassignment), and never use <strong>var</strong>.
            </p>
    </section>

    <section class="topic">
        <h2>Equality and coercion</h2>
            <p>
                Javascript has two ways to compare values: 
            </p>
            <section class="code-group">
<pre><code>
== // loose equality

=== // strict equality
</code></pre>
            </section>
            <p>
                <strong>Loose equality</strong> tries to convert to the same data type before comparing,
                while <strong>Strict equality</strong> compares both the type and value.
            </p>
            <section class="code-group">
<pre><code>
"3" == 3 //true
"3" === 3 //false
</code></pre>
            </section>
            <p>
                Don't confuse this with Java's syntax. Always use strict equality to avoid unexpected results.
            </p>
    </section>

    <section class="topic">
        <h2>Falsy values</h2>
            <p>
                Some values are automatically considered <strong>falsy</strong>
                meaning they behave like <strong>false</strong> in conditions:
            </p>
            <section class="code-group">
<pre><code>
false, 0, "", null, undefined, NaN
</code></pre>
            </section>
            <p>
                Everything else is considered <strong>truthy</strong>.
                This is important when writing for example <strong>if</strong> statements,
                so your code doesn't behave unexpectedly.
            </p>
    </section>

    <section class="topic">
        <h2>Functions</h2>
            <p>
                Functions (as in any programming language) are reusable blocks of code.
                Although, in Javascript, functions are what we call <strong>First class citizens</strong>.
                This means, that they can be stored in variables, passed on as arguments, and returned from other functions.
            </p>
            <p>
                Below are some examples on how to define functions in Javascript:
            </p>
                <section class="code-group">
<pre><code>
// function declaration
function greet() {
    console.log("this reminds me of Java!") 
}

// function expression
const greetAgain = function() {
    console.log("wait this isn't like Java...")
}

// arrow function
(() => console.log("uhm, what's with the arrow???"))();
</code></pre>
                </section>
            <p>
                Now the main difference between function declaration, expression and arrow functions are <strong>hoisting</strong>
                Declarations are hoisted to the top of their scope, which means they can be called before
                they are defined. This does not apply to function expression and arrow functions.
            </p>
                <section class="code-group">
<pre><code>
sayHello(); // this will work due to hoisting

function sayHello() {
    console.log("hello");
}

sayHi(); // this will however, not work

const sayHi = function() {
    console.log("hi")
}
</code></pre>
                </section>
            <p>
                As we mentioned before, functions can be passed as arguments. 
                A function that is passed as an argument to another function, is called a <strong>callback function</strong>.
            </p>
            <p>
                Callback functions are typically used to run code, after something else has finished.
            </p>
                <section class="code-group">
<pre><code>
function greetUser(callback) {
    console.log("welcome!");
callback();
}

function sayGoodbye() {
    console.log("goodbye!");
}

greetUser(sayGoodbye);
//output:
//welcome!
//goodbye!
</code></pre>
                </section>
            <p>
                Loop methods like:
            </p>
                <section class="code-group">
<pre><code>
const numbers = [1, 2, 3, 4, 5, 6];

// forEach - runs a function for each element
numbers.forEach(num => console.log(num));
// output: 1, 2, 3, 4, 5, 6

// map - creates a new array by transforming each element
const doubledNumbers = numbers.map(num => num * 2);
console.log(doubledNumbers); // 2, 4, 6, 8, 10, 12

// filter - only keeps elements that meet a condition
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // 2, 4, 6

// reduce - reduces all values to a single result
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 21

// find - returns the first element that matches a condition
const firstOverFour = numbers.find(num => num > 4);
console.log(firstOverFour); // 5

// indexOf - finds the index position of a specific value
const index = numbers.indexOf(3);
console.log(index); // 2
</code></pre>
                </section>

            <p>
                All utilize callback functions. It is highly recommended to use these
                rather than traditionally looping through the array with <strong>for</strong>.
                Loop methods are more readable, safer and easier to maintain. 
            </p>
            <h3>8 reasons to use loop methods</h3>
                <ol>
                    <li><strong>Brevity</strong> fewer lines of code for the same task.</li>
                    <li><strong>Clarity</strong> communicates intent directly</li>
                    <li><strong>No indexing</strong> no need to manually track index <strong>i</strong></li>
                    <li><strong>Avoids confusion</strong> between 'for of/in'</li>
                    <li><strong>Access to both value and index</strong> in one callback function </li>
                    <li><strong>Avoids side effects</strong> doesn't mutate</li>
                    <li><strong>Shorter and more maintainable/readable</strong></li>
                    <li><strong>Non-mutating </strong> methods like map and filter return new a array instead of mutating original list</li>
                </ol>
    </section>

    <section class="topic">
        <h2>Dates in Javascript</h2>
            <p>
                Javascript has a built-in <strong>Date</strong> object that allows you to work with dates and times.
                You can use it to get the current time, day, or month:
            </p>
            <section class="code-group">
<pre><code>
// get the current date and time
console.log(new Date()); // result: 2025-10-20T18:45:00.000Z
</code></pre>
            </section>
            <p>
                If we wanted to get the current month (with a string representation)
                we could do something like this:
            </p>
            <section class="code-group">
<pre><code>
const months = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
];

const currentMonth = months[new Date().getMonth()];
console.log(currentMonth); // output: "October"
</code></pre>
            </section>
            <p>
                On the other hand, we can use <strong>toLocaleDateString()</strong> to format the date automatically,
                based on language and region:
            </p>
            <section class="code-group">
<pre><code>
const monthName = new Date().toLocaleDateString("en-uk", { month: "long" });
const dayName = new Date().toLocaleDateString("en-uk", { weekday: "long" });

console.log(monthName, dayName); // output: "October Monday"
</code></pre>
            </section>
            <p>
                <code>{ month: "long" }</code> says you want the month in long format (October).
                <code>{ weekday: "long" }</code> says you want the weekday in long format (Monday).
                And together, they let you display readable localized dates without having to build your own arrays.
            </p>
    </section>

    <section class="topic">
        <h2>Fetch</h2>
            <p>
                When you run Javascript code - it runs from top to bottom, as you would expect.
                Sometimes though, you need to wait for something slow like a network request.
                This is what we call <strong>asynchronous code</strong>.
            </p>
            <p>
                Now, you might remember that we mentioned <strong>callback functions</strong> before.
                Callbacks were the original way to handle asynchronous code. 
                That being code that needs to be run after something else has finished.
            </p>
            <p>
                Before 2017, Javascript programmers were deep in the trenches of what we call <strong>callback hell</strong>.
                This term refers to a situation where callbacks are nested <strong>inside</strong> callbacks,
                making the code messy and difficult to read.
            </p>
            <p>
                To solve this Javascript introduced <strong>Promises</strong>, and later <strong>Async/Await</strong>.
            </p>
            <p>
                A <strong>Promise</strong> is a Javascript object that represents
                a value that might not be available yet.
            </p>
            <p>
                Now, a Promise can be in one of three states: <strong>pending</strong>,
                <strong>fulfilled</strong> or <strong>rejected</strong>.
            </p>
            <p>
                Let's say you wanted to get some data from another server.
                That server might be experiencing high traffic og be down,
                and you don't want to run your code without having the data.
            </p>
            <p>
                To handle this, we use <strong>fetch()</strong> which returns a Promise.
                We can then use <strong>.then()</strong> and <strong>.catch()</strong>
                to handle the result:
            </p>
            <section class="code-group">
<pre><code>
fetch("https://jsonplaceholder.typicode.com/users")
    .then(response => response.json())
    .then(data => console.log("users:", data))
    .catch(error => console.log("error:", error));
</code></pre>
            </section>
            <p>
                This piece of code might look like it runs synchronously, but it doesn't.
                The <strong>fetch()</strong> function is asynchronous.
                It starts the network request, and then continues running the rest of your code,
                while waiting for the response. 
                When the data comes back, the <strong>.then()</strong> function is triggered.
            </p>
    </section>

</section>