<section class="rest-page">
    <section class="intro">
        <h1>REST API</h1>
            <p>
                REST stands for "<strong>Re</strong>presentation <strong>S</strong>tate <strong>T</strong>ransfer"
            </p>
            <p>
                It is a set of guidelines for building web API's.
                Boiled down, it is basically exposing <strong>resources</strong> (always in nouns),
                over HTTP using standard methods: <strong>GET, POST, PUT, PATCH, DELETE</strong> and return data in JSON.
            </p>
    </section>

    <section class="topic">
        <h2>Anatomy of a URL</h2>
            <p>
                Before we dive deeper into REST, it is important to understand the anatomy of an URL:
            </p>

<pre><code>
https://www.google.com/search?h1=en&q=pay%20attention
|             |        |
|             |        └─ endpoint
|             └────────── domain
└──────────────────────── protocol  
</code></pre>

            <p>
                The <strong>protocol</strong> (http/https) defines how the client communicates with the server.
            </p>
            <p>
                The <strong>domain</strong>, where "www" is the <strong>sub-level</strong> and ".com" is the <strong>top-level</strong>, points to the server location.
            </p>
            <p>
                The <strong>endpoint</strong> specifies the resource you want to access.
            </p>
            <p>
                The endpoint could look something like this:
            </p>

<pre><code>
/search?h1=en&q=pay%20attention
|      |______________________|
|                └ query string
└───────────────── path
</code></pre>

            <p>
                The <strong>query</strong> contains query parameters seperated by <code>&amp;</code>
                and starts with a <code>?</code>.
            </p>
            <p>
                The <strong>path</strong> identifies a specific resource.
            </p>

    </section>

    <section class="topic">
        <h2>HTTP Methods</h2>
            <p>
                We follow an ordering of the HTTP methods.
                This is mainly due to how a user naturally would interact with a webapp.
            </p>

<pre><code>
1. GET    - retrieve data
2. POST   - create new data
3. PUT    - replace existing data
4. PATCH  - update parts of existing data
5. DELETE - remove data
</code></pre>

            <p>
                If you look at these methods and think: "that seems familiar" - that's because it is.
                The methods can be directly mapped to the CRUD operations: <strong>Create, Read, Update, Delete</strong>.
            </p>
            <p>
                Now, in REST we talk about something called <strong>idempotency</strong>.
                It transletes to: an operation that delivers the same result no matter how many times you execute it.
            </p>
            <p>
                GET, PUT and DELETE are idempotent and that is important because
                calling them multiple times won't change the outcome.
                However, POST is not. Calling it multiple times will result in multiple
                resources being created.
            </p>
            <p>
                In REST, we also talk about <strong>safe</strong> methods.
                A safe method is defined by a method that does not alter nor create resources.
                The only safe method we have is GET, since it is a read-only method.
            </p>
    </section>

    <section class="topic">
        <h2>State in REST</h2>
            <p>
                When a client makes a request to the server, it never remembers the client's state between requests.
                Every request is treated as something completely new.
            </p>
            <p>
                Therefore, it is important that every request must contain everything 
                the server needs to process it.
            </p>
            <p>
                This is called <strong>statelessness</strong> and it keeps the server simple and scalable.
                It doesn't need to track sessions or remember user history.
            </p>
    </section>

    <section class="topic">
        <h2>Resource naming &amp; URL Design</h2>
            <p>
                When you expose an API, it is important to model the URL correctly.
                In REST we use <strong>nouns</strong>, not verbs.
                Translated: Resources, NOT actions.
            </p>

<pre><code>
// example of good practice
GET /api/friends
GET /api/friends/5
GET /api/friends/5/posts
GET /api/friends/5/posts/2
</code></pre>

<pre><code>
// example of bad practice
GET  /api/getFriends
POST /api/createFriend
PUT  /api/updateFriend/3
</code></pre>

            <p>
                The idea is, that the endpoint represents a <strong>resource</strong> not an action.
                But then how do he we show what action we want to perform?
            </p>
            <p>
                We let the <strong>HTTP methods</strong> show intent. GET, POST, PUT etc. describe what we want to do with the resource.
            </p>

<pre><code>
GET    /api/friends
GET    /api/friends/2
POST   /api/friends
PUT    /api/friends/2
PATCH  /api/friends/2
DELETE /api/friends/2
</code></pre>

            <p>
                Now, in my earlier example <code>GET /api/friends/5/posts</code> you'll notice that there are <strong>two resources</strong>.
                There's <strong>friends</strong> and <strong>posts</strong>. Since posts belongs to a specific friend, 
                this is called a <strong>sub-resource</strong>.
            </p>
            <p>
                This relationship is represented in the URL, and makes it clear which resource belongs to which.
            </p>
    </section>

    <section topic="topic">
        <h2>HTTP Status Codes</h2>
            <p>
                Every response from a REST API includes a status code.
                The code returned indicate if a specific request has been successfully completed.
            </p>

<pre><code>
1. informational responses (100-199)
2. successful respones     (200-299)
3. redirection messages    (300-399)
4. client error responses  (400-499)
5. server error responses  (500-599)
</code></pre>

            <p>Now, you don't need to know every singe status code, so here are some of the most common:</p>

<pre><code>
200 OK                    - Request succeeded
201 Created               - Resource created
204 No content            - Request sucess but no data returned

400 Bad request           - Invalid request or missing data
401 Unauthorized          - Missing or invalid authentication
403 Forbidden             - Not allowed to access the resource
404 Not found             - The resource could not be found

500 Internal Server Error - Something went wrong on the server
</code></pre>

            <p>
                It is generally good practice to return appropriate status codes with your responses.
                It helps the client understand what happened (and makes debugging A LOT easier).
            </p>
    </section>

    <section topic="topic">
        <h2>Richardson Maturity Model</h2>
            <p>
                The Richardson Maturity Model is a way of measuring how RESTful an API is.
                It contains 4 levels, from 0 to 3, where each level adds more on the previous.
            </p>
            <h3>Level 0: The swamp of POX</h3>
            <p>
                This is the lowest level. Typically it consists of a single URI (uniform resource identifier)
                supporting all the CRUD operations. The HTTP method used is <strong>POST</strong>
            </p>

<pre><code>     
/bookingService - POST - retrieve, add/cancel 
                    for destinations/hotels/rooms
</code></pre>

            <h3>Level 1: Resources</h3>
            <p>
                Level 1 introduces resources and splits the URI into multiple
                individual URIs. Although, the HTTP methods used is still POST.
            </p>

<pre><code>
/bookingDestination - POST - retrieve dest.
/bookingReservation - POST - add/cancel res.
/bookingRooms       - POST - add/cancel req. to res.
/bookingFeedback    - POST - leave feedback
</code></pre>

            <h3>Level 2: HTTP verbs</h3>
            <p>
                Level 2 makes use of the HTTP verbs which allows for further specialization
                of the resource. Each resource now has its own endpoint, and the HTTP method describes the action.
            </p>

<pre><code>
/destinations - GET - retrieve
/reservations - GET - retrieve
/reservations - POST - add/cancel
/rooms        - DELETE - remove
</code></pre>

            <h3>Level 3: Hypermedia Controls</h3>
            <p>
                This level introduces HATEOAS (Hypermedia As The Engine Of Application).
                It basically adds links to related resources, so the client can discover what to do next.
            </p>

<pre><code>
{
    "id": 1,
    "destination": "Copenhagen",
    "_links": {
        "self": { "href: "/bookings/1"},
        "cancel": { "href": "/bookings/1/cancel"},
        "feedback": { "href": "/bookings/1/feedback"}
    }
}
</code></pre>
    </section>
</section>