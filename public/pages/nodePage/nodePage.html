<section class="node-page">
    <section class="intro">
        <h1>Node.js</h1>
            <p class="lead muted">
                Node.js is a open source, cross-platform Javascript runtime environment.
                It can run Javascript code outside a web browser, and make server side scripting.
                It represents the "Javascript everywhere" paradigm.
            </p>
            <p>
                In short: we can use Javascript in both <strong>frontend</strong> and <strong>backend</strong>.
            </p>
            <p>
                (bad news for all you Java-glazers)
            </p>

            <p>
                Fun fact: according to a Stack Overflow Developer Survey, Node.js is one of
                the most commonly used web technologies!
                (translation: you need to learn Node.js!)
            </p>
            <p>
                Fun fact again: Google once made an entire frontend framework where you write 
                <strong>Java</strong> to get <strong>JavaScript</strong>.
                They called it "GWT" - I call it "solving problems that didn't exist".
                (if they wanted type safety, why not just use TypeScript?)
            </p>
    </section>

    <section class="topic">
        <h2>npm &amp; package.json</h2>
            <p>
                <code>npm</code> (Node Package Manager) is a tool we use to install, share and manage Javasctipt libraries.
                It comes bundled with Node.js.
            </p>
            <p>
                Every Node.js project starts with <code>npm init</code>.
                This creates a <code>package.json</code> file that will keep track of your dependencies and scripts.
            </p>
            <p>
                You could think of it as <strong>Maven's pom.xml</strong>. They both describe the projects dependencies,
                but npm just keeps things lightweight and human readable.
            </p>
            <p>
                The <code>package.json</code> is the heart of every Node project.
                It tells npm which packages to install and defines the scripts you can run with simple commands.
            </p>
            <section class="code-group">
<pre><code>{
    "name": "node-demo",
    "version": "0.0.1",
    "scripts": {
        "start": "node app.js",
        "dev": "nodemon app.js"
    },
    "dependencies": {
        "express": "^5.10.0"
    },
    "devDependencies": {
        "nodemon": "^3.1.10"
    }
}
</code></pre>
            </section>
            <p>
                Once defined, use <code>npm install</code> or the shorthand <code>npm i</code>
                 to install the projects dependencies.
            </p>
            <p>
                The installed dependencies will be placed in a folder called <code>node_modules</code>.
                You never push this to Github. Always add it to your <code>.gitignore</code> file.
            </p>
            <p>
                To summarize: dependencies are packages your project needs to run, 
                while devDependencies are the tools you use during coding like nodemon or testing libraries.
            </p>
    </section>

    <section class="topic">
        <h2>Nodemon</h2>
            <p>
               Normally, when you would like to run your project, you'd write <code>node app.js</code> 
               every time you'd made a change.
            </p>
            <p>
                That's great and all, for about 5 minutes. Then it gets old fast.
            </p>
            <p>
                This is where Nodemon comes in. Made a change? Nodemon simply restarts your program
            </p>
            <p>
                As stated before, Nodemon is installed as devDependency since you don't need it in production.
            </p>
            <p>
                Simply run <code>npm i -D nodemon</code> (the flag -D marks it as a devDependency).
            </p>
            <p>
                Once installed, you can add a <code>dev</code> script to your package.json:
            </p>
            <section class="code-group">
<pre><code>"scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js"
}</code></pre>
            </section>
            <p>
                Now, you can simply run: <code>npm run dev</code>
            </p>
            <p>
                Nodemon will now keep an eye out for changes in your files
                and restart your app every time you make a change/hit save.
            </p>
            <p>
                It is very useful for small projects but can become inefficient in large applications.
            </p>
    </section>

    <section class="topic">
        <h2>CommonJS &amp; ES Modules</h2>
            <p>
                Node.js supports two different module systems: <code>CommonJS</code> and <code>ES Modules</code>.
                Basically, they do the same thing - split your code into smaller, reusable files. Just with different syntax.
            </p>
            <p>
                CommonJS is the original Node.js module system and it uses <code>require()</code> to import,
                and <code>module.exports</code> to export code.
            </p>
            <section class="code-group">
<pre><code>
// iLoveJs.js
function sayILoveJs() {
    console.log("i love JS!");
}
module.exports = { sayILoveJs };

// app.js
const { sayILoveJs } = require('./iLoveJs.js');

sayILoveJs();
</code></pre>
            </section>
            <p>
                On the other hand, ES Modules uses <code>import</code> and <code>export</code> instead
            </p>
            <section class="code-group">
<pre><code>
// iLoveJs.js
export function sayILoveJs() {
    console.log("i love JS!");
}

// app.js
import { sayILoveJs } from './iLoveJs'

sayILoveJs();
</code></pre>
            </section>
            <p>
                Now, i know what you're thinking: if they they're doing the same thing, why have two different ways to do it?
            </p>
            <p>
                CommonJS came first. It was designed for Node.js, and worked server side.
                Some time later, Javascript introduced a module system called ES Modules 
                and it became the official standard for both browsers (client side) and Node.js (server side).
            </p>
            <p>
                ES modules are resolved <strong>asynchronously</strong>,
                while CommonJS loads modules <strong>synchronously</strong>.
            </p>
            <p>
                In more modern projects, you'll mostly use ES Modules.
            </p>
    </section>

    <section class="topic">
        <h2>Environment Variables</h2>
            <p>
                Environment variables store things like API keys, database URLs/passwords etc.
                It is extremely important that these are not hardcoded in your files.
            </p>
            <p>
                In Node.js there are several ways to do this. You could do it natively with <code>process.env</code>
            </p>
            <section class="code-group">
<pre><code>
    const API_KEY = process.env.YOUR_API_KEY;
</code></pre>
            </section>
            <p>
                And then you define these in your terminal:
            </p>
            <section class="code-group">
<pre><code>
    $env:YOUR_API_KEY="efgh12" node app.js
</code></pre>
            </section>
            <p>The other way is to use a library like <code>dotenv</code>, but I won't elaborate further on this.</p>
    </section>

    <section class="topic">
        <h2>Built in modules</h2>
            <p>
                Node.js comes with built in modules that you can use without installing anything.
                This includes <code>fs</code> (file system) and <code>path</code> (file paths).
            </p>
            <section class="code-group">
<pre><code>
// reading a file
import fs from 'fs';

const data = fs.readFileSync("./components/header.html").toString();
</code></pre>
            </section>
            <p>
                This code reads the content of the file, and converts it to a string.
            </p>
    </section>
</section>